package com.github.mmolimar.ksql.jdbc

import java.sql._
import java.util
import java.util.concurrent.Executor
import java.util.{Collections, Optional, Properties}

import com.github.mmolimar.ksql.jdbc.Exceptions._
import io.confluent.ksql.rest.client.{BasicCredentials, KsqlRestClient, RestResponse}
import io.confluent.ksql.rest.entity.KsqlEntityList

import scala.collection.JavaConverters._
import scala.util.{Failure, Success, Try}

case class KsqlConnectionValues(ksqlServer: String,
                                port: Int,
                                username: Option[String],
                                password: Option[String],
                                config: Map[String, String]) {

  def ksqlUrl: String = {
    val protocol = if (isSecured) "https://" else "http://"
    protocol + ksqlServer + ":" + port
  }

  def jdbcUrl: String = {
    val ksqlUserPass = username.flatMap(usr => password.map(pass => s"$usr:$pass@")).getOrElse("")
    val suffix = if (config.isEmpty) "" else "?"
    s"${KsqlDriver.ksqlPrefix}$ksqlUserPass$ksqlServer:$port$suffix${
      config.map(c => s"${c._1}=${c._2}").mkString("&")
    }"
  }

  def isSecured: Boolean = config.getOrElse("secured", "false").toBoolean

  def properties: Boolean = config.getOrElse("properties", "false").toBoolean

  def timeout: Long = config.getOrElse("timeout", "0").toLong

}

class ConnectionNotSupported extends Connection with WrapperNotSupported {

  override def commit(): Unit = throw NotSupported("commit")

  override def getHoldability: Int = throw NotSupported("getHoldability")

  override def setCatalog(catalog: String): Unit = throw NotSupported("setCatalog")

  override def setHoldability(holdability: Int): Unit = throw NotSupported("setHoldability")

  override def prepareStatement(sql: String): PreparedStatement = throw NotSupported("prepareStatement")

  override def prepareStatement(sql: String, resultSetType: Int, resultSetConcurrency: Int): PreparedStatement =
    throw NotSupported("prepareStatement")

  override def prepareStatement(sql: String, resultSetType: Int, resultSetConcurrency: Int,
                                resultSetHoldability: Int): PreparedStatement = throw NotSupported("prepareStatement")

  override def prepareStatement(sql: String, autoGeneratedKeys: Int): PreparedStatement =
    throw NotSupported("prepareStatement")

  override def prepareStatement(sql: String, columnIndexes: scala.Array[Int]): PreparedStatement =
    throw NotSupported("prepareStatement")

  override def prepareStatement(sql: String, columnNames: scala.Array[String]): PreparedStatement =
    throw NotSupported("prepareStatement")

  override def createClob: Clob = throw NotSupported("createClob")

  override def setSchema(schema: String): Unit = throw NotSupported("setSchema")

  override def setClientInfo(name: String, value: String): Unit = throw NotSupported("setClientInfo")

  override def setClientInfo(properties: Properties): Unit = throw NotSupported("setClientInfo")

  override def createSQLXML: SQLXML = throw NotSupported("createSQLXML")

  override def getCatalog: String = throw NotSupported("getCatalog")

  override def createBlob: Blob = throw NotSupported("createBlob")

  override def createStatement: Statement = throw NotSupported("createStatement")

  override def createStatement(resultSetType: Int, resultSetConcurrency: Int): Statement =
    throw NotSupported("createStatement")

  override def createStatement(resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int): Statement =
    throw NotSupported("createStatement")

  override def abort(executor: Executor): Unit = throw NotSupported("abort")

  override def setAutoCommit(autoCommit: Boolean): Unit = throw NotSupported("setAutoCommit")

  override def getMetaData: DatabaseMetaData = throw NotSupported("getMetaData")

  override def setReadOnly(readOnly: Boolean): Unit = throw NotSupported("setReadOnly")

  override def prepareCall(sql: String): CallableStatement = throw NotSupported("prepareCall")

  override def prepareCall(sql: String, resultSetType: Int, resultSetConcurrency: Int): CallableStatement =
    throw NotSupported("prepareCall")

  override def prepareCall(sql: String, resultSetType: Int, resultSetConcurrency: Int,
                           resultSetHoldability: Int): CallableStatement = throw NotSupported("prepareCall")

  override def setTransactionIsolation(level: Int): Unit = throw NotSupported("setTransactionIsolation")

  override def getWarnings: SQLWarning = throw NotSupported("getWarnings")

  override def releaseSavepoint(savepoint: Savepoint): Unit = throw NotSupported("releaseSavepoint")

  override def nativeSQL(sql: String): String = throw NotSupported("nativeSQL")

  override def isReadOnly: Boolean = throw NotSupported("isReadOnly")

  override def createArrayOf(typeName: String, elements: scala.Array[AnyRef]): Array =
    throw NotSupported("createArrayOf")

  override def setSavepoint(): Savepoint = throw NotSupported("setSavepoint")

  override def setSavepoint(name: String): Savepoint = throw NotSupported("setSavepoint")

  override def close(): Unit = throw NotSupported("close")

  override def createNClob: NClob = throw NotSupported("createNClob")

  override def rollback(): Unit = throw NotSupported("rollback")

  override def rollback(savepoint: Savepoint): Unit = throw NotSupported("rollback")

  override def setNetworkTimeout(executor: Executor, milliseconds: Int): Unit = throw NotSupported("setNetworkTimeout")

  override def setTypeMap(map: util.Map[String, Class[_]]): Unit = throw NotSupported("setTypeMap")

  override def isValid(timeout: Int): Boolean = throw NotSupported("isValid")

  override def getAutoCommit: Boolean = throw NotSupported("getAutoCommit")

  override def clearWarnings(): Unit = {
    // TODO
    //  we currently do not support this,
    //  but we can't throw a SQLException because we want to support ontop
  }

  override def getSchema: String = throw NotSupported("getSchema")

  override def getNetworkTimeout: Int = throw NotSupported("getNetworkTimeout")

  override def isClosed: Boolean = throw NotSupported("isClosed")

  override def getTransactionIsolation: Int = throw NotSupported("getTransactionIsolation")

  override def createStruct(typeName: String, attributes: scala.Array[AnyRef]): Struct = throw NotSupported("createStruct")

  override def getClientInfo(name: String): String = throw NotSupported("getClientInfo")

  override def getClientInfo: Properties = throw NotSupported("getClientInfo")

  override def getTypeMap: util.Map[String, Class[_]] = throw NotSupported("getTypeMap")

}

class KsqlConnection(private[jdbc] val values: KsqlConnectionValues, properties: Properties)
  extends ConnectionNotSupported {

  private val ksqlClient = init
  private var connected: Option[Boolean] = None

  private[jdbc] def init: KsqlRestClient = {
    val (localProps, clientProps) = if (values.properties) {
      val local = properties.asScala.toMap[String, AnyRef].filterNot(_._1.toLowerCase.startsWith("ssl.")).asJava
      val client = properties.asScala.toMap[String, String].filter(_._1.toLowerCase.startsWith("ssl.")).asJava
      (local, client)
    } else {
      (Collections.emptyMap[String, AnyRef], Collections.emptyMap[String, String])
    }
    val credentials = values.username
      .flatMap(user => values.password.map(pass => Optional.of(BasicCredentials.of(user, pass))))
      .getOrElse(Optional.empty[BasicCredentials])
    KsqlRestClient.create(values.ksqlUrl, localProps, clientProps, credentials)
  }

  private[jdbc] def validate(): Unit = {
    Try(ksqlClient.getServerInfo) match {
      case Success(response) if response.isErroneous =>
        throw CannotConnect(values.ksqlServer, response.getErrorMessage.getMessage)
      case Failure(e) => throw CannotConnect(values.ksqlServer, e.getMessage)
      case _ => connected = Some(true)
    }
  }

  private[jdbc] def executeKsqlCommand(ksql: String): RestResponse[KsqlEntityList] = ksqlClient.makeKsqlRequest(ksql)

  override def setAutoCommit(autoCommit: Boolean): Unit = {}

  override def getTransactionIsolation: Int = Connection.TRANSACTION_NONE

  override def getMetaData: DatabaseMetaData = new KsqlDatabaseMetaData(this)

  override def createStatement: Statement = createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY)

  override def createStatement(resultSetType: Int, resultSetConcurrency: Int): Statement = {
    createStatement(resultSetType, resultSetConcurrency, ResultSet.HOLD_CURSORS_OVER_COMMIT)
  }

  override def createStatement(resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int): Statement = {
    if (resultSetType != ResultSet.TYPE_FORWARD_ONLY ||
      resultSetConcurrency != ResultSet.CONCUR_READ_ONLY ||
      resultSetHoldability != ResultSet.HOLD_CURSORS_OVER_COMMIT) {
      throw NotSupported("ResultSetType, ResultSetConcurrency and ResultSetHoldability must be" +
        " TYPE_FORWARD_ONLY, CONCUR_READ_ONLY, HOLD_CURSORS_OVER_COMMIT respectively.")
    }
    new KsqlStatement(ksqlClient, values.timeout)
  }

  override def setClientInfo(name: String, value: String): Unit = {
    val ksql = s"SET '${name.trim}'='${value.trim}';"
    if (ksqlClient.makeKsqlRequest(ksql).isErroneous) {
      throw InvalidProperty(name)
    }
  }

  override def setClientInfo(properties: Properties): Unit = {
    properties.asScala.foreach(entry => setClientInfo(entry._1, entry._2))
  }

  override def isReadOnly: Boolean = false

  override def getCatalog: String = None.orNull

  override def setCatalog(catalog: String): Unit = {}

  override def close(): Unit = {
    ksqlClient.close()
    connected = Some(false)
  }

  override def getAutoCommit: Boolean = false

  override def getSchema: String = None.orNull

  override def isValid(timeout: Int): Boolean = ksqlClient.makeStatusRequest.isSuccessful

  override def isClosed: Boolean = !connected.getOrElse(throw NotConnected(values.jdbcUrl))

  override def getWarnings: SQLWarning = None.orNull

  override def commit(): Unit = {}

}
