package com.github.mmolimar.ksql.jdbc

import java.io.InputStream
import java.sql.{Connection, ResultSet, SQLWarning, Statement, Types}

import com.github.mmolimar.ksql.jdbc.Exceptions._
import com.github.mmolimar.ksql.jdbc.resultset.{StreamedResultSet, _}
import io.confluent.ksql.parser.{DefaultKsqlParser, KsqlParser}
import io.confluent.ksql.rest.client.{KsqlRestClient, QueryStream, RestResponse}
import io.confluent.ksql.rest.entity._
import io.confluent.ksql.schema.ksql.{SqlBaseType => KsqlType}

import scala.collection.JavaConverters._
import scala.language.implicitConversions
import scala.util.{Failure, Success, Try}

private object KsqlStatement {

  private val ksqlParser: KsqlParser = new DefaultKsqlParser

}

class StatementNotSupported extends Statement with WrapperNotSupported {

  override def cancel(): Unit = throw NotSupported("cancel")

  override def getResultSetHoldability: Int = throw NotSupported("getResultSetHoldability")

  override def getMaxFieldSize: Int = throw NotSupported("getMaxFieldSize")

  override def getUpdateCount: Int = throw NotSupported("getUpdateCount")

  override def setPoolable(poolable: Boolean): Unit = throw NotSupported("setPoolable")

  override def getFetchSize: Int = throw NotSupported("getFetchSize")

  override def setQueryTimeout(seconds: Int): Unit = throw NotSupported("setQueryTimeout")

  override def setFetchDirection(direction: Int): Unit = throw NotSupported("setFetchDirection")

  override def setMaxRows(max: Int): Unit = throw NotSupported("setMaxRows")

  override def setCursorName(name: String): Unit = throw NotSupported("setCursorName")

  override def getFetchDirection: Int = throw NotSupported("getFetchDirection")

  override def getResultSetType: Int = throw NotSupported("getResultSetType")

  override def getMoreResults: Boolean = throw NotSupported("getMoreResults")

  override def getMoreResults(current: Int): Boolean = throw NotSupported("getMoreResults")

  override def addBatch(sql: String): Unit = throw NotSupported("addBatch")

  override def execute(sql: String): Boolean = throw NotSupported("execute")

  override def execute(sql: String, autoGeneratedKeys: Int): Boolean = throw NotSupported("execute")

  override def execute(sql: String, columnIndexes: Array[Int]): Boolean = throw NotSupported("execute")

  override def execute(sql: String, columnNames: Array[String]): Boolean = throw NotSupported("execute")

  override def executeQuery(sql: String): ResultSet = throw NotSupported("executeQuery")

  override def isCloseOnCompletion: Boolean = throw NotSupported("isCloseOnCompletion")

  override def getResultSet: ResultSet = throw NotSupported("getResultSet")

  override def getMaxRows: Int = throw NotSupported("getMaxRows")

  override def setEscapeProcessing(enable: Boolean): Unit = throw NotSupported("setEscapeProcessing")

  override def executeUpdate(sql: String): Int = throw NotSupported("executeUpdate")

  override def executeUpdate(sql: String, autoGeneratedKeys: Int): Int = throw NotSupported("executeUpdate")

  override def executeUpdate(sql: String, columnIndexes: Array[Int]): Int = throw NotSupported("executeUpdate")

  override def executeUpdate(sql: String, columnNames: Array[String]): Int = throw NotSupported("executeUpdate")

  override def getQueryTimeout: Int = throw NotSupported("getQueryTimeout")

  override def getWarnings: SQLWarning = throw NotSupported("getWarnings")

  override def getConnection: Connection = throw NotSupported("getConnection")

  override def setMaxFieldSize(max: Int): Unit = throw NotSupported("setMaxFieldSize")

  override def isPoolable: Boolean = throw NotSupported("isPoolable")

  override def clearBatch(): Unit = throw NotSupported("clearBatch")

  override def close(): Unit = throw NotSupported("close")

  override def closeOnCompletion(): Unit = throw NotSupported("closeOnCompletion")

  override def executeBatch: Array[Int] = throw NotSupported("executeBatch")

  override def getGeneratedKeys: ResultSet = throw NotSupported("getGeneratedKeys")

  override def setFetchSize(rows: Int): Unit = throw NotSupported("setFetchSize")

  override def clearWarnings(): Unit = throw NotSupported("clearWarnings")

  override def getResultSetConcurrency: Int = throw NotSupported("getResultSetConcurrency")

  override def isClosed: Boolean = throw NotSupported("isClosed")
}

class KsqlStatement(private val ksqlClient: KsqlRestClient, val timeout: Long = 0) extends StatementNotSupported {

  import KsqlStatement._

  private[this] var currentResultSet: Option[ResultSet] = None
  private var maxRows = 0
  private var closed = false

  override def cancel(): Unit = {
    currentResultSet.foreach(_.close)
    currentResultSet = None
  }

  override def close(): Unit = {
    cancel()
    closed = true
  }

  override def isClosed: Boolean = closed

  override def getResultSet: ResultSet = currentResultSet.getOrElse(throw ResultSetError("Result set not initialized."))

  override def getUpdateCount: Int = -1

  override def getMaxRows: Int = maxRows

  override def getMoreResults: Boolean = !isClosed && currentResultSet.isDefined && (currentResultSet.get match {
    case srs: StreamedResultSet => srs.hasNext
    case irs: IteratorResultSet[_] => irs.rows.hasNext
  })

  override def getMoreResults(current: Int): Boolean = getMoreResults

  private def executeKsqlRequest(sql: String): Unit = {
    if (closed) throw AlreadyClosed("Statement already closed.")

    currentResultSet = None
    val fixedSql = fixSql(sql)
    val stmt = Try(ksqlParser.parse(fixedSql)) match {
      case Failure(e) => throw KsqlQueryError(s"Error parsing query '$fixedSql': ${e.getMessage}.", None, e)
      case Success(s) if s.isEmpty => throw KsqlQueryError("Query cannot be empty.")
      case Success(s) if s.size() > 1 => throw KsqlQueryError("You have to execute just one query at a time. " +
        s"Number of queries sent: '${s.size}'.")
      case Success(s) => s.get(0)
    }

    val response = stmt.getStatement.statement.getStart.getText.trim.toUpperCase match {
      case "SELECT" =>
        ksqlClient.makeQueryRequest(fixedSql, None.orNull).asInstanceOf[RestResponse[AnyRef]]
      case "PRINT" =>
        ksqlClient.makePrintTopicRequest(fixedSql, None.orNull).asInstanceOf[RestResponse[AnyRef]]
      case _ =>
        ksqlClient.makeKsqlRequest(fixedSql).asInstanceOf[RestResponse[AnyRef]]
    }
    if (response.isErroneous) {
      throw KsqlQueryError(s"Error executing KSQL request: '$fixedSql'", Some(response.getErrorMessage))
    }

    val resultSet: ResultSet = response.get match {
      case e: QueryStream =>
        implicit lazy val queryDesc: QueryDescription = {
          val response = ksqlClient.makeKsqlRequest(s"EXPLAIN $fixedSql")
          if (response.isErroneous) {
            throw KsqlQueryError(s"Error getting metadata for query: '$fixedSql'", Some(response.getErrorMessage))
          } else if (response.getResponse.size != 1) {
            throw KsqlEntityListError("Invalid metadata for result set.")
          }
          response.getResponse.get(0).asInstanceOf[QueryDescriptionEntity]
          }.getQueryDescription
        e
      case e: KsqlEntityList => e.asInstanceOf[KsqlEntityList]
      case e: InputStream => e.asInstanceOf[InputStream]
    }
    currentResultSet = Some(resultSet)
  }

  override def execute(sql: String): Boolean = {
    executeKsqlRequest(sql)
    currentResultSet.nonEmpty
  }

  //TODO
  override def execute(sql: String, autoGeneratedKeys: Int): Boolean = execute(sql)

  //TODO
  override def execute(sql: String, columnIndexes: Array[Int]): Boolean = execute(sql)

  //TODO
  override def execute(sql: String, columnNames: Array[String]): Boolean = execute(sql)

  override def executeQuery(sql: String): ResultSet = {
    executeKsqlRequest(sql)
    currentResultSet.getOrElse(throw ResultSetError("Result set not initialized."))
  }

  override def getResultSetType: Int = ResultSet.TYPE_FORWARD_ONLY

  override def getResultSetHoldability: Int = ResultSet.HOLD_CURSORS_OVER_COMMIT

  override def setMaxRows(max: Int): Unit = if (max < 0) throw InvalidValue("maxRows", max.toString) else maxRows = max

  override def getWarnings: SQLWarning = None.orNull

  private def fixSql(sql: String): String = {
    Option(sql).filter(_.trim.nonEmpty).map(s => if (s.trim.last == ';') s else s + ";").getOrElse("")
  }

  private implicit def toResultSet(stream: QueryStream)
                                  (implicit queryDesc: QueryDescription): ResultSet = {
    def mapType(ksqlType: KsqlType): (Int, Int) = ksqlType match {
      case KsqlType.INTEGER => (Types.INTEGER, 16)
      case KsqlType.BIGINT => (Types.BIGINT, 32)
      case KsqlType.DOUBLE => (Types.DOUBLE, 32)
      case KsqlType.DECIMAL => (Types.DECIMAL, 32)
      case KsqlType.BOOLEAN => (Types.BOOLEAN, 8)
      case KsqlType.STRING => (Types.VARCHAR, 128)
      case KsqlType.MAP => (Types.JAVA_OBJECT, 255)
      case KsqlType.ARRAY => (Types.ARRAY, 255)
      case KsqlType.STRUCT => (Types.STRUCT, 255)
    }

    val columns = queryDesc.getFields.asScala.map { f =>
      val (mappedType, length) = mapType(f.getSchema.getType)
      HeaderField(f.getName, mappedType, length)
    }.toList
    new StreamedResultSet(new KsqlResultSetMetaData(columns), new KsqlQueryStream(stream), maxRows, timeout)
  }

  private implicit def toResultSet(stream: InputStream): ResultSet = {
    new StreamedResultSet(new KsqlResultSetMetaData(KsqlEntityHeaders.printTopic),
      new KsqlInputStream(stream), maxRows, timeout)
  }

  private implicit def toResultSet(list: KsqlEntityList): ResultSet = {
    import KsqlEntityHeaders._

    if (list.size > 1) throw KsqlEntityListError(s"KSQL entity list with an invalid number of entities: '${list.size}'.")
    list.asScala.headOption.map {
      case e: CommandStatusEntity =>
        val rows = Iterator(Seq(
          e.getCommandSequenceNumber,
          e.getCommandId.getType.name,
          e.getCommandId.getEntity,
          e.getCommandId.getAction.name,
          e.getCommandStatus.getStatus.name,
          e.getCommandStatus.getMessage
        ))
        new IteratorResultSet[Any](commandStatusEntity, maxRows, rows)
      case e: ConnectorDescription =>
        val sources = if (e.getSources.isEmpty) {
           Seq(new SourceDescription(
             "", List.empty.asJava, List.empty.asJava, List.empty.asJava, "", "", "", "", "", false, "", "", 0, 0)
           )
        } else {
          e.getSources.asScala
        }
        val rows = sources.map(s => Seq(
          e.getConnectorClass,
          e.getStatus.name,
          e.getStatus.`type`.name,
          e.getStatus.connector.state,
          e.getStatus.connector.trace,
          e.getStatus.connector.workerId,
          e.getStatus.tasks.asScala.map(t => s"${t.id}-${t.state}-${t.workerId}: ${Option(t.trace).getOrElse("")}").mkString("\n"),
          s.getKey,
          s.getName,
          s.getType,
          s.getTopic,
          s.getFormat,
          s.getFields.asScala.map(f => s"${f.getName}:${f.getSchema.getTypeName}").mkString(", "),
          s.getPartitions,
          s.getReplication,
          s.getStatistics,
          s.getErrorStats,
          s.getTimestamp,
          e.getTopics.asScala.mkString(", ")
        )).toIterator
        new IteratorResultSet[Any](connectorDescriptionEntity, maxRows, rows)
      case e: ConnectorList =>
        val rows = e.getConnectors.asList.asScala.map(c => Seq(
          c.getName,
          Option(c.getType).map(_.name).getOrElse(""),
          c.getClassName
        )).toIterator
        new IteratorResultSet[String](connectorListEntity, maxRows, rows)
      case e: CreateConnectorEntity =>
        val rows = Iterator(Seq(
          e.getInfo.name,
          Option(e.getInfo.`type`).map(_.name).getOrElse(""),
          e.getInfo.tasks.asScala.map(t => s"[${t.task}]-${t.connector}").mkString("\n"),
          e.getInfo.config.asScala.map(c => s"${c._1} -> ${c._2}").mkString("\n")
        ))
        new IteratorResultSet[String](createConnectorEntity, maxRows, rows)
      case e: DropConnectorEntity =>
        val rows = Iterator(Seq(
          e.getConnectorName
        ))
        new IteratorResultSet[String](dropConnectorEntity, maxRows, rows)
      case e: ErrorEntity =>
        new IteratorResultSet[String](errorEntity, maxRows, Iterator(Seq(e.getErrorMessage)))
      case e: ExecutionPlan =>
        new IteratorResultSet[String](executionPlanEntity, maxRows, Iterator(Seq(e.getExecutionPlan)))
      case e: FunctionDescriptionList =>
        val rows = e.getFunctions.asScala.map(f => Seq(
          e.getName,
          e.getType.name,
          e.getDescription,
          e.getPath,
          e.getVersion,
          e.getAuthor,
          f.getDescription,
          f.getReturnType,
          f.getArguments.asScala.map(arg => s"${arg.getName}:${arg.getType}").mkString(", ")
        )).toIterator
        new IteratorResultSet[String](functionDescriptionListEntity, maxRows, rows)
      case e: FunctionNameList =>
        val rows = e.getFunctions.asScala.map(f => Seq(
          f.getName,
          f.getType.name
        )).toIterator
        new IteratorResultSet[String](functionNameListEntity, maxRows, rows)
      case e: KafkaTopicsList =>
        val rows = e.getTopics.asScala.map(t => Seq(
          t.getName,
          t.getReplicaInfo.asScala.mkString(", ")
        )).toIterator
        new IteratorResultSet[String](kafkaTopicsListEntity, maxRows, rows)
      case e: KafkaTopicsListExtended =>
        val rows = e.getTopics.asScala.map(t => Seq(
          t.getName,
          t.getReplicaInfo.asScala.mkString(", "),
          t.getConsumerCount,
          t.getConsumerGroupCount,
        )).toIterator
        new IteratorResultSet[Any](kafkaTopicsListExtendedEntity, maxRows, rows)
      case e: PropertiesList =>
        val rows = e.getProperties.asScala.map(p => Seq(
          p._1,
          Option(p._2).map(_.toString).getOrElse("UNDEFINED")
        )).toIterator
        new IteratorResultSet[String](propertiesListEntity, maxRows, rows)
      case e: Queries =>
        val rows = e.getQueries.asScala.map(q => Seq(
          q.getId.getId,
          q.getQueryString,
          q.getSinks.asScala.mkString(", ")
        )).toIterator
        new IteratorResultSet[String](queriesEntity, maxRows, rows)
      case e@(_: QueryDescriptionEntity | _: QueryDescriptionList) =>
        val descriptions: Seq[QueryDescription] = e match {
          case qde: QueryDescriptionEntity => Seq(qde.getQueryDescription)
          case qdl: QueryDescriptionList => qdl.getQueryDescriptions.asScala
        }
        val rows = descriptions.map(d => Seq(
          d.getId.getId,
          d.getFields.asScala.map(_.getName).mkString(", "),
          d.getSources.asScala.mkString(", "),
          d.getSinks.asScala.mkString(", "),
          d.getTopology,
          d.getExecutionPlan,
          d.getState.orElse("")
        )).toIterator
        new IteratorResultSet[String](queryDescriptionEntityList, maxRows, rows)
      case e@(_: SourceDescriptionEntity | _: SourceDescriptionList) =>
        val descriptions: Seq[SourceDescription] = e match {
          case sde: SourceDescriptionEntity => Seq(sde.getSourceDescription)
          case sdl: SourceDescriptionList => sdl.getSourceDescriptions.asScala
        }
        val rows = descriptions.map(d => Seq(
          d.getKey,
          d.getName,
          d.getType,
          d.getTopic,
          d.getFormat,
          d.getFields.asScala.map(f => s"${f.getName}:${f.getSchema.getTypeName}").mkString(", "),
          d.getPartitions,
          d.getReplication,
          d.getStatistics,
          d.getErrorStats,
          d.getTimestamp
        )).toIterator
        new IteratorResultSet[Any](sourceDescriptionEntityList, maxRows, rows)
      case e: StreamsList =>
        val rows = e.getStreams.asScala.map(s => Seq(
          s.getName,
          s.getTopic,
          s.getFormat
        )).toIterator
        new IteratorResultSet[String](streamsListEntity, maxRows, rows)
      case e: TablesList =>
        val rows = e.getTables.asScala.map(t => Seq(
          t.getName,
          t.getTopic,
          t.getFormat,
          t.getIsWindowed
        )).toIterator
        new IteratorResultSet[Any](tablesListEntity, maxRows, rows)
      case e: TopicDescription =>
        val rows = Iterator(Seq(
          e.getName,
          e.getKafkaTopic,
          e.getFormat,
          e.getSchemaString
        ))
        new IteratorResultSet[String](topicDescriptionEntity, maxRows, rows)
      case e: TypeList =>
        val rows = e.getTypes.asScala.map(t => Seq(
          t._1,
          t._2.getTypeName
        )).toIterator
        new IteratorResultSet[String](typesListEntity, maxRows, rows)
    }.getOrElse(new IteratorResultSet[Any](List.empty, maxRows, Iterator.empty))
  }

}
