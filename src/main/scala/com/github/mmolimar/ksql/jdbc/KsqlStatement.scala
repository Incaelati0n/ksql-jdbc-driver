package com.github.mmolimar.ksql.jdbc

import java.io.InputStream
import java.sql.{Connection, ResultSet, SQLWarning, Statement, Types}

import com.github.mmolimar.ksql.jdbc.Exceptions._
import com.github.mmolimar.ksql.jdbc.resultset._
import io.confluent.ksql.parser.KsqlParser
import io.confluent.ksql.rest.client.{KsqlRestClient, RestResponse}
import io.confluent.ksql.rest.entity.SchemaInfo.{Type => KsqlType}
import io.confluent.ksql.rest.entity._

import scala.collection.JavaConverters._
import scala.util.{Failure, Success, Try}

private object KsqlStatement {

  private val ksqlParser: KsqlParser = new KsqlParser

}

class StatementNotSupported extends Statement with WrapperNotSupported {

  override def cancel: Unit = throw NotSupported("cancel")

  override def getResultSetHoldability: Int = throw NotSupported("getResultSetHoldability")

  override def getMaxFieldSize: Int = throw NotSupported("getMaxFieldSize")

  override def getUpdateCount: Int = throw NotSupported("getUpdateCount")

  override def setPoolable(poolable: Boolean): Unit = throw NotSupported("setPoolable")

  override def getFetchSize: Int = throw NotSupported("getFetchSize")

  override def setQueryTimeout(seconds: Int): Unit = throw NotSupported("setQueryTimeout")

  override def setFetchDirection(direction: Int): Unit = throw NotSupported("setFetchDirection")

  override def setMaxRows(max: Int): Unit = throw NotSupported("setMaxRows")

  override def setCursorName(name: String): Unit = throw NotSupported("setCursorName")

  override def getFetchDirection: Int = throw NotSupported("getFetchDirection")

  override def getResultSetType: Int = throw NotSupported("getResultSetType")

  override def getMoreResults: Boolean = throw NotSupported("getMoreResults")

  override def getMoreResults(current: Int): Boolean = throw NotSupported("getMoreResults")

  override def addBatch(sql: String): Unit = throw NotSupported("addBatch")

  override def execute(sql: String): Boolean = throw NotSupported("execute")

  override def execute(sql: String, autoGeneratedKeys: Int): Boolean = throw NotSupported("execute")

  override def execute(sql: String, columnIndexes: Array[Int]): Boolean = throw NotSupported("execute")

  override def execute(sql: String, columnNames: Array[String]): Boolean = throw NotSupported("execute")

  override def executeQuery(sql: String): ResultSet = throw NotSupported("executeQuery")

  override def isCloseOnCompletion: Boolean = throw NotSupported("isCloseOnCompletion")

  override def getResultSet: ResultSet = throw NotSupported("getResultSet")

  override def getMaxRows: Int = throw NotSupported("getMaxRows")

  override def setEscapeProcessing(enable: Boolean): Unit = throw NotSupported("setEscapeProcessing")

  override def executeUpdate(sql: String): Int = throw NotSupported("executeUpdate")

  override def executeUpdate(sql: String, autoGeneratedKeys: Int): Int = throw NotSupported("executeUpdate")

  override def executeUpdate(sql: String, columnIndexes: Array[Int]): Int = throw NotSupported("executeUpdate")

  override def executeUpdate(sql: String, columnNames: Array[String]): Int = throw NotSupported("executeUpdate")

  override def getQueryTimeout: Int = throw NotSupported("getQueryTimeout")

  override def getWarnings: SQLWarning = throw NotSupported("getWarnings")

  override def getConnection: Connection = throw NotSupported("getConnection")

  override def setMaxFieldSize(max: Int): Unit = throw NotSupported("setMaxFieldSize")

  override def isPoolable: Boolean = throw NotSupported("isPoolable")

  override def clearBatch: Unit = throw NotSupported("clearBatch")

  override def close: Unit = throw NotSupported("close")

  override def closeOnCompletion: Unit = throw NotSupported("closeOnCompletion")

  override def executeBatch: Array[Int] = throw NotSupported("executeBatch")

  override def getGeneratedKeys: ResultSet = throw NotSupported("getGeneratedKeys")

  override def setFetchSize(rows: Int): Unit = throw NotSupported("setFetchSize")

  override def clearWarnings: Unit = throw NotSupported("clearWarnings")

  override def getResultSetConcurrency: Int = throw NotSupported("getResultSetConcurrency")

  override def isClosed: Boolean = throw NotSupported("isClosed")
}

class KsqlStatement(private val ksqlClient: KsqlRestClient, val timeout: Long = 0) extends StatementNotSupported {

  import KsqlStatement._

  private[this] var currentResultSet: Option[ResultSet] = None
  private var maxRows = 0

  override def cancel: Unit = {
    currentResultSet.map(_.close)
    currentResultSet = None
  }

  override def getResultSet: ResultSet = currentResultSet.getOrElse(throw ResultSetError("Result set not initialized."))

  override def getUpdateCount: Int = -1

  override def getMaxRows: Int = maxRows

  private def executeKsqlRequest(sql: String): Unit = {
    currentResultSet = None
    val fixedSql = fixSql(sql)
    val stmt = Try(ksqlParser.getStatements(fixedSql)) match {
      case Failure(e) => throw KsqlQueryError(s"Error parsing query '$fixedSql': ${e.getMessage}.", e)
      case Success(s) if s.size() != 1 => throw KsqlQueryError("You have to execute just one query at a time. " +
        s"Number of queries sent: '${s.size}'.")
      case Success(s) => s.get(0)
    }

    val response = stmt.getStatement.statement.getStart.getText.trim.toUpperCase match {
      case "SELECT" =>
        ksqlClient.makeQueryRequest(fixedSql).asInstanceOf[RestResponse[AnyRef]]
      case "PRINT" =>
        ksqlClient.makePrintTopicRequest(fixedSql).asInstanceOf[RestResponse[AnyRef]]
      case _ =>
        ksqlClient.makeKsqlRequest(fixedSql).asInstanceOf[RestResponse[AnyRef]]
    }
    if (response.isErroneous) {
      import scala.collection.JavaConverters._
      throw KsqlQueryError(s"Error executing KSQL request: '$fixedSql'. " +
        s"Error: ${response.getErrorMessage.getStackTrace.asScala.mkString("\n")}")
    }

    val resultSet: ResultSet = response.get match {
      case e: KsqlRestClient.QueryStream => {
        implicit lazy val queryDesc = {
          val response = ksqlClient.makeKsqlRequest(s"EXPLAIN $fixedSql")
          if (response.isErroneous) {
            import scala.collection.JavaConverters._
            throw KsqlQueryError(s"Error getting metadata for query: '$fixedSql'. " +
              s"Error: ${response.getErrorMessage.getStackTrace.asScala.mkString("\n")}.")
          } else if (response.getResponse.size != 1) {
            throw KsqlEntityListError("Invalid metadata for result set.")
          }
          response.getResponse.get(0).asInstanceOf[QueryDescriptionEntity]
        }.getQueryDescription

        e.asInstanceOf[KsqlRestClient.QueryStream]
      }
      case e: KsqlEntityList => e.asInstanceOf[KsqlEntityList]
      case e: InputStream => e.asInstanceOf[InputStream]
    }
    currentResultSet = Some(resultSet)
  }

  override def execute(sql: String): Boolean = {
    executeKsqlRequest(sql)
    currentResultSet.nonEmpty
  }

  //TODO
  override def execute(sql: String, autoGeneratedKeys: Int): Boolean = execute(sql)

  //TODO
  override def execute(sql: String, columnIndexes: Array[Int]): Boolean = execute(sql)

  //TODO
  override def execute(sql: String, columnNames: Array[String]): Boolean = execute(sql)

  override def executeQuery(sql: String): ResultSet = {
    executeKsqlRequest(sql)
    currentResultSet.getOrElse(throw ResultSetError("Result set not initialized."))
  }

  override def getResultSetType: Int = ResultSet.TYPE_FORWARD_ONLY

  override def setMaxRows(max: Int): Unit = if (max < 0) throw InvalidValue("maxRows", max.toString) else maxRows = max

  override def getWarnings: SQLWarning = None.orNull

  private def fixSql(sql: String): String = {
    Option(sql).filter(_.trim.nonEmpty).map(s => if (s.trim.last == ';') s else s + ";").getOrElse("")
  }

  private implicit def toResultSet(stream: KsqlRestClient.QueryStream)
                                  (implicit queryDesc: QueryDescription): ResultSet = {
    def mapType(ksqlType: KsqlType): (Int, Int) = ksqlType match {
      case KsqlType.INTEGER => (Types.INTEGER, 16)
      case KsqlType.BIGINT => (Types.BIGINT, 32)
      case KsqlType.DOUBLE => (Types.DOUBLE, 32)
      case KsqlType.BOOLEAN => (Types.BOOLEAN, 8)
      case KsqlType.STRING => (Types.VARCHAR, 128)
      case KsqlType.MAP => (Types.JAVA_OBJECT, 255)
      case KsqlType.ARRAY => (Types.ARRAY, 255)
      case KsqlType.STRUCT => (Types.STRUCT, 255)
    }

    val columns = queryDesc.getFields.asScala.map { f =>
      val (mappedType, length) = mapType(f.getSchema.getType)
      HeaderField(f.getName, mappedType, length)
    }.toList
    new StreamedResultSet(new KsqlResultSetMetaData(columns), new KsqlQueryStream(stream), maxRows, timeout)
  }

  private implicit def toResultSet(stream: InputStream): ResultSet = {
    new StreamedResultSet(new KsqlResultSetMetaData(KsqlEntityHeaders.printTopic),
      new KsqlInputStream(stream), maxRows, timeout)
  }

  private implicit def toResultSet(list: KsqlEntityList): ResultSet = {
    import KsqlEntityHeaders._

    if (list.size != 1) throw KsqlEntityListError(s"KSQL entity list with an invalid number of entities: '${list.size}'.")
    list.asScala.headOption.map(_ match {
      case e: CommandStatusEntity => {
        val rows = Iterator(Seq(
          e.getCommandId.getType.name,
          e.getCommandId.getEntity,
          e.getCommandId.getAction.name,
          e.getCommandStatus.getStatus.name,
          e.getCommandStatus.getMessage
        ))
        new IteratorResultSet[String](commandStatusEntity, maxRows, rows)
      }
      case e: ExecutionPlan => new IteratorResultSet[String](executionPlanEntity, maxRows, Iterator(Seq(e.getExecutionPlan)))
      case e: FunctionDescriptionList => {
        val rows = e.getFunctions.asScala.map(f => Seq(
          e.getAuthor,
          e.getDescription,
          e.getName,
          e.getPath,
          e.getVersion,
          e.getType.name,
          f.getDescription,
          f.getReturnType,
          f.getArguments.asScala.map(arg => s"${arg.getName}:${arg.getType}").mkString(", ")
        )).toIterator
        new IteratorResultSet[String](functionDescriptionListEntity, maxRows, rows)
      }
      case e: FunctionNameList => {
        val rows = e.getFunctions.asScala.map(f => Seq(
          f.getName,
          f.getType.name
        )).toIterator
        new IteratorResultSet[String](functionNameListEntity, maxRows, rows)
      }
      case e: KafkaTopicsList => {
        val rows = e.getTopics.asScala.map(t => Seq(
          t.getName,
          t.getConsumerCount,
          t.getConsumerGroupCount,
          t.getRegistered.booleanValue,
          t.getReplicaInfo.asScala.mkString(", ")
        )).toIterator
        new IteratorResultSet[Any](kafkaTopicsListEntity, maxRows, rows)
      }
      case e: KsqlTopicsList => {
        val rows = e.getTopics.asScala.map(t => Seq(
          t.getName,
          t.getKafkaTopic,
          t.getFormat.name
        )).toIterator
        new IteratorResultSet[String](ksqlTopicsListEntity, maxRows, rows)
      }
      case e: PropertiesList => {
        val rows = e.getProperties.asScala.map(p => Seq(
          p._1,
          p._2.toString
        )).toIterator
        new IteratorResultSet[String](propertiesListEntity, maxRows, rows)
      }
      case e: Queries => {
        val rows = e.getQueries.asScala.map(q => Seq(
          q.getId.getId,
          q.getQueryString,
          q.getSinks.asScala.mkString(", ")
        )).toIterator
        new IteratorResultSet[String](queriesEntity, maxRows, rows)
      }
      case e@(_: QueryDescriptionEntity | _: QueryDescriptionList) => {
        val descriptions: Seq[QueryDescription] = if (e.isInstanceOf[QueryDescriptionEntity]) {
          Seq(e.asInstanceOf[QueryDescriptionEntity].getQueryDescription)
        } else {
          e.asInstanceOf[QueryDescriptionList].getQueryDescriptions.asScala
        }

        val rows = descriptions.map(d => Seq(
          d.getId.getId,
          d.getFields.asScala.map(_.getName).mkString(", "),
          d.getSources.asScala.mkString(", "),
          d.getSinks.asScala.mkString(", "),
          d.getTopology,
          d.getExecutionPlan
        )).toIterator
        new IteratorResultSet[String](queryDescriptionEntityList, maxRows, rows)
      }
      case e@(_: SourceDescriptionEntity | _: SourceDescriptionList) => {
        val descriptions: Seq[SourceDescription] = if (e.isInstanceOf[SourceDescriptionEntity]) {
          Seq(e.asInstanceOf[SourceDescriptionEntity].getSourceDescription)
        } else {
          e.asInstanceOf[SourceDescriptionList].getSourceDescriptions.asScala
        }

        val rows = descriptions.map(d => Seq(
          d.getKey,
          d.getName,
          d.getTopic,
          d.getType,
          d.getFormat,
          d.getFields.asScala.map(f => s"${f.getName}:${f.getSchema.getTypeName}").mkString(", "),
          d.getPartitions,
          d.getStatistics,
          d.getErrorStats,
          d.getTimestamp
        )).toIterator
        new IteratorResultSet[Any](sourceDescriptionEntityList, maxRows, rows)
      }
      case e: StreamsList => {
        val rows = e.getStreams.asScala.map(s => Seq(
          s.getName,
          s.getTopic,
          s.getFormat
        )).toIterator
        new IteratorResultSet[String](streamsListEntity, maxRows, rows)
      }
      case e: TablesList => {
        val rows = e.getTables.asScala.map(t => Seq(
          t.getName,
          t.getTopic,
          t.getFormat,
          t.getIsWindowed
        )).toIterator
        new IteratorResultSet[Any](tablesListEntity, maxRows, rows)
      }
      case e: TopicDescription => {
        val rows = Iterator(Seq(
          e.getName,
          e.getKafkaTopic,
          e.getFormat,
          e.getSchemaString
        ))
        new IteratorResultSet[String](topicDescriptionEntity, maxRows, rows)
      }
    }).getOrElse(throw KsqlCommandError(s"Cannot build result set for '${list.get(0).getStatementText}'."))
  }

}
